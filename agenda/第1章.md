# 第1章 リファクタリングーー最初の例
- リファクタリングがどのように行われるのか、リファクタリングの感覚を伝える
- 例示された実装だけで考えない。大きなシステムの一部だと考える

## スタート地点
- 劇団員を派遣して演劇パフォーマンスを行う会社

## 着手前のコメント
- 規模が大きくなると、一つの関数だけでは理解が難しくなる。　
- 汚いコードを変更するのは難しい。どこを変更すべきか、既存コードのへの影響は何かが特定しづらくなるから。それにより、バグを生みやすくなる。
- **機能追加が簡単になるようにリファクタリング -> 新規機能を追加 の順で行うこと。**
  - 長く使われるプログラムで、既存のコードをコピペした場合、次の仕様変更で二つの関数を変更しなければならなくなる。
  - 今後変更があった場合、変更しなければならない箇所は複数になる可能性が高い。
  - プログラムを今後も変更するなら、コードの改善は必要。

## リファクタリングの第一歩
- **最初にすることはテストコードを書くことである。**
- 数秒で結果が出るテストを何度も実行しながら、リファクタリングを行う。
- **テストは実行結果を自己診断する必要がある。**

## statement関数の分割
- 長い関数をリファクタリングする時は、全体を分割できる場所を探す。
- コードについて理解できたことを、頭の中に留めておかない。コードに移動させる。その方法は、意味のあるコードの塊を関数にして、名前をつけること。 -> **「関数の抽出」と呼ぶ**
  - まずスコープ外になる変数がないかを確認。
  - 引数、返却値を決めて、抽出した関数に置き換える。
  - コードを変更したらすぐにテストする。その際、変更は小さく。大きすぎると間違っていた時のデバッグが大変になる。
- 単純に関数を抽出した後、コードをみて変更できる場所を探す。
  - 返却値となる変数の名をわかりやすいもの（result）に変更する。
  - 動的型付け言語では、名前から方がわかるようになっていた方が便利。変数名を適切に変更する。
- **すぐれたプログラマは人間にとってわかりやすいコードを書く**
- 変数の名前を付け替える必要はあるか？ -> ある。変数名はコードを明快にするための鍵。
### play変数の削除
- play変数は削除すべき -> パラメータで渡す必要がないため。
- **「問い合わせによる一次変数の置き換え」を使う。**
- **「変数のインライン化」を行う。**
- **「関数宣言の変更」を行う**
- リファクタリングすることによってパフォーマンスが変わる可能性があるが、今回は影響は大きくない。また、きれいなコードであれば後からチューニングすることは容易。
- ローカル変数を削除すると、メソッドが抽出しやすくなる。
### ボリューム特典ポイントの計算部分の抽出
- 関数に切り出す。その後、関数の引数名を改善（play変数の削除とほぼ同様）。
### format変数の削除
- 一時変数（format）を取り除く。
- **「関数宣言の変更」を行う。**
- 関数に適切な名前をつけることで、処理について知るために中身を読まなくてもよくなる。
  - 初めから適切な名前がつけられないこともある。
### ボリューム特典ポイント集計箇所の削除
1. **「ループの分離」を行う。** 
  - 一時変数を取り除く（一時変数があることで、ルーチンが複雑になりやすくなる）
2. **「ステートメントのスライド」を行う。**
  - 修正を加えたい変数を使っている箇所を一つにすることで、リファクタリングを進めやすくする。
3. **「関数の抽出」**を行い、処理全体を独立させる。
4. **「変数のインライン化」**を行う。

- リファクタリングとパフォーマンスについて（前にも書かれていたがさらに細かく説明している）
  - リファクタリングによって、パフォーマンスが悪化する可能性はある。しかしループを増やした程度でパフォーマンスが悪化することはほとんどない。
  - もし、パフォーマンスが悪化した場合でも、まずはいったんリファクタリングを進める。リファクタリングが終わった後、チューニングするようにする。
  - 整理されたコードの方がチューニングが施しやすくなる。
- 小さなステップでリファクタリングを行う。
  - こまめなテストとコミットで、問題が起きた場合は、それを素早く把握・リカバリーできる。
  - 小さなステップを踏むことで、結局素早い変更が可能になる。

 - volumeCreditsに関して行ってたリファクタリングの手順と同様に、totalAmountに対してリファクタリングを行う。

## 計算とフォーマットにフェーズを分割
- **「フェーズの分離」を行うように、リファクタリングを進める**
  - 前半でデータの計算、後半で出力を行うようにする。
  - 前半と後半が受け渡すデータを作成する（手法としてはこれまでとほぼ同様。「変数のインライン化」「変数のインライン化」などを使用）

## 現況：二つのファイル（とフェーズ）への分離
- **プログラミングでもキャンプ場のルールに従う。コードベースは最初に見た時よりもきれいに保つ。**

## 型による計算処理の再編成
- 条件ロジックは、構造的要素によって補強しない限り、修正につれて荒廃する。今回は型によるポリモーフィズムを使うのが適切。
  - 継承構造の導入。
  - 料金とボリューム特典ポイントのメソッドを定義するクラスを定義。
  - 「ポリモーフィズムによる条件記述の置き換え」を実施。
### PerformanceCalculatorの作成
- データの変換部分を一箇所にまとめることで、一貫性が生まれ、コードが読みやすくなる。
  - **「関数宣言の変更」を行う。**
### 関数をPerformanceCalculatorに移動
- より重要なロジックを移動させる。関数のコンテキストが変わるため、**「関数の移動」**の手順を追って進める。
  1. 新しいコンテキストにロジックをコピー。
  2. コードを新たな場所に適した形に書き換え。
  3. 元の関数を新しい関数に委譲するように書き換え。
  4. **「関数のインライン化」**を使い、新しい関数を直接呼び出し。
### PerformanceCalculatorをポリモーフィックに
- ポリモーフィズムを使う
  1. **「サブクラスによるタイプコードの書き換え」**を用いて、サブクラスを導入、タイプコードを排除。
    - JavaScriptのコンストラクタは、サブクラスのインスタンスを返せないため、コンストラクタの呼び出しを関数呼び出しに変更する必要がある。-> **「関数によるコンストラクタの置き換え」**を導入。
  2. **「ポリモーフィズムによる条件記述の置き換え」**を行う。  
    
